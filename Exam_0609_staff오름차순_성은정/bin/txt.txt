Set<E> : 집합

{1,2,3} {2,1,3} 같은 집합인가? ㅇㅇ, 순서는 상관없다
{x| x는 3 이하의 양수}
1. 순서가 없다
2. 중복이 없다
(list는 순서와 중복이 있음, 들어온 차례대로 0, 1, 2..)

Set을 언제 쓸까?
메뉴판(배달앱, 메뉴 순서가 상관없고 중복이 있으면 안 됨)

HashSet, LinkedHashSet, TreeSet이 있음


[HashSet]
hash란 임의의 데이터를 입력 받았을 때, 고정 크기의 해시코드를 출력 하는 것
hash의 특징 3가지를 꼭 알자
hashSet은 hash의 기능을 들고 있구나

set.add(new Num(45));
set.add(new Num(23));
set.add(new Num(634));
set.add(new Num(3));
set.add(new Num(45));

1. set.add(new Num(45));
2. set.add(new Num(23)); < 얘가 들어올 때, 45.equals를 해서 들어옴
근데 equals는 Object를 비교함, 당연히 모든 Object는 다 다르기 때문에 다 다르다고 나옴
그래서 equals를 재정의 해주자

근데 equals를 재정의 해줘도 중복이 제거 되지 않음 왜?

자료의 개수가 많아 질수록 비교 횟수가 증가 됨 (자료의 개수, 비교횟수 => 비례 관계)
> 자료의 개수가 많아지더라도 비교 횟수가 고정적이면?, 비교 횟수를 낮추자 : Hash로!
Hash는 필수임, 안 만들면 오동작이 됨!
> grouping을 하자

set 안에 부분집합을 만들자
분류를 하자

예를들어 남녀별로 키 제일 큰 사람을 찾는다
1. 남자, 여자를 분류
2. 남녀 별로 키를 잼 씨잼~

어떤 데이터
비트열ㅁ
ㅁ
ㅁ      =>  Hash    => ㅁㅁㅁ
ㅁ

8(2^3)개중 하나의 값을 가지게 된다 (예를들어서 Hash 비트를 3비트로)
(해시 코드가 짧아질수록 중복 가능성이 증가 됨)

1. ㅁ 해시 코드 : 000
2. ㅁ 해시 코드 : 101
=> 이 2개의 데이터는 다름
해시 코드의 길이가 짧아졌다 하더라도
해시 코드가 다르다면 두 원본 데이터는 서로 다르다

1. ㅁ 해시 코드 : 000
2. ㅁ 해시 코드 : 101
3. ㅁ 해시 코드 : 101
=> 해시 충돌로 인해서(해시 코드가 짧아서 생김) 같은 코드가 나올 수도 있음
   진짜 같을 수도 있고, 해시 충돌로 인해 다른 값이지만 같은 해시 코드가 나올 수도 있음
3이 들어 왔을때, 1과 비교 할 필요가 있을까? ㄴㄴ
2와 비교 하면 됨. 101끼리

만약
1. ㅁ 해시 코드 : 000
2. ㅁ 해시 코드 : 101
3. ㅁ 해시 코드 : 101
4. ㅁ 해시 코드 : 000
이면 4번은 해시 코드 101(2번과 3번)이랑 비교 할 필요가 없음

Hash값이 같으면, 같은 Hash끼리 비교 하면 됨
Hash값이 다르면 그냥 다른거임

*HashSet의 기본 메카니즘
1. hashCode를 호출해서 값을 얻어온다.
2. equals 함수를 호출해서 같은지 확인한다.

Comparable I/F : Sorting(정렬)을 구현하기 위한 인터페이스
정렬을 하는데 왜 비교를 해야할까?
정렬은 기계적으로 표현하자면 비교를 여러번 하는 동작
오름차순으로 정렬하는 방법은 많이 있다 (버블 정렬, 셀렉션 정렬, quik정렬 ...)
컴퓨터는 비교를 할 때, 2개씩만 비교 가능